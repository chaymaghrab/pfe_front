import { CellClassFunc, CellClassRules, CellClickedEvent, CellContextMenuEvent, CellDoubleClickedEvent, CellEditorSelectorFunc, CellRendererSelectorFunc, CellStyle, CellStyleFunc, CheckboxSelectionCallback, ColDef, ColGroupDef, ColSpanParams, ColumnsMenuParams, DndSourceCallback, DndSourceOnRowDragParams, EditableCallback, GetQuickFilterTextParams, HeaderCheckboxSelectionCallback, HeaderClass, HeaderValueGetterFunc, IAggFunc, ICellRendererComp, ICellRendererFunc, IRowDragItem, ITooltipParams, KeyCreatorParams, NewValueParams, RowDragCallback, RowNode, RowSpanParams, SuppressHeaderKeyboardEventParams, SuppressKeyboardEventParams, SuppressNavigableCallback, SuppressPasteCallback, ToolPanelClass, ValueFormatterFunc, ValueGetterFunc, ValueParserFunc, ValueSetterFunc } from "ag-grid-community";
import { QueryList } from "@angular/core";
import * as ɵngcc0 from '@angular/core';
export declare class AgGridColumn {
    childColumns: QueryList<AgGridColumn>;
    hasChildColumns(): boolean;
    toColDef(): ColDef;
    private getChildColDefs;
    private createColDefFromGridColumn;
    filterFramework: any;
    filterParams: any;
    floatingFilterComponent: any;
    floatingFilterComponentParams: any;
    floatingFilterComponentFramework: any;
    floatingFilterFramework: any;
    filter: any;
    /** The name to render in the column header. If not specified and field is specified, the field name will be used as the header name.     */
    headerName: string | undefined;
    /** Function or expression. Gets the value for display in the header.     */
    headerValueGetter: string | HeaderValueGetterFunc | undefined;
    /** Tooltip for the column header     */
    headerTooltip: string | undefined;
    /** CSS class to use for the header cell. Can be a string, array of strings, or function.     */
    headerClass: HeaderClass | undefined;
    /** Suppress the grid taking action for the relevant keyboard event when a header is focused.     */
    suppressHeaderKeyboardEvent: ((params: SuppressHeaderKeyboardEventParams) => boolean) | undefined;
    /** Whether to show the column when the group is open / closed.     */
    columnGroupShow: string | undefined;
    /** CSS class to use for the tool panel cell. Can be a string, array of strings, or function.     */
    toolPanelClass: ToolPanelClass | undefined;
    /** Set to `true` if you do not want this column or group to appear in the Columns Tool Panel. Default: `false`     */
    suppressColumnsToolPanel: boolean | undefined;
    /** Set to `true` if you do not want this column (filter) or group (filter group) to appear in the Filters Tool Panel. Default: `false`     */
    suppressFiltersToolPanel: boolean | undefined;
    /** Provide your own tooltip component for the column.
     * See [Tooltip Component](https://www.ag-grid.com/javascript-data-grid/component-tooltip/) for framework specific implementation details.     */
    tooltipComponent: any;
    /** @deprecated As of v27, use `tooltipComponent` for framework components too.
     */
    tooltipComponentFramework: any;
    /** The params used to configure `tooltipComponent`.     */
    tooltipComponentParams: any;
    /** A list containing a mix of columns and column groups.     */
    children: (ColDef | ColGroupDef)[] | undefined;
    /** The unique ID to give the column. This is optional. If missing, a unique ID will be generated. This ID is used to identify the column group in the column API.     */
    groupId: string | undefined;
    /** Set to `true` if this group should be opened by default. Default: `false`     */
    openByDefault: boolean | undefined;
    /** Set to `true` to keep columns in this group beside each other in the grid. Moving the columns outside of the group (and hence breaking the group) is not allowed. Default: `false`     */
    marryChildren: boolean | undefined;
    /** The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used.
     * See [Header Group Component](https://www.ag-grid.com/javascript-data-grid/component-header/#header-group-components/) for framework specific implementation details.     */
    headerGroupComponent: any;
    /** @deprecated As of v27, use `headerGroupComponent` for framework components too.
     */
    headerGroupComponentFramework: any;
    /** The params used to configure the `headerGroupComponent`.     */
    headerGroupComponentParams: any;
    /** The unique ID to give the column. This is optional. If missing, the ID will default to the field.
     * If both field and colId are missing, a unique ID will be generated.
     * This ID is used to identify the column in the API for sorting, filtering etc.     */
    colId: string | undefined;
    /** The field of the row to get the cells data from     */
    field: string | undefined;
    /** A comma separated string or array of strings containing `ColumnType` keys which can be used as a template for a column.
     * This helps to reduce duplication of properties when you have a lot of common column properties.     */
    type: string | string[] | undefined;
    /** Function or expression. Gets the value from your data for display.     */
    valueGetter: string | ValueGetterFunc | undefined;
    /** A function or expression to format a value, should return a string. Not used for CSV export or copy to clipboard, only for UI cell rendering.     */
    valueFormatter: string | ValueFormatterFunc | undefined;
    /** Provided a reference data map to be used to map column values to their respective value from the map.     */
    refData: {
        [key: string]: string;
    } | undefined;
    /** Function to return a string key for a value.
     * This string is used for grouping, Set filtering, and searching within cell editor dropdowns.
     * When filtering and searching the string is exposed to the user, so make sure to return a human-readable value.     */
    keyCreator: ((params: KeyCreatorParams) => string) | undefined;
    /** Custom comparator for values, used by renderer to know if values have changed. Cells who's values have not changed don't get refreshed.
     * By default the grid uses `===` is used which should work for most use cases.     */
    equals: ((valueA: any, valueB: any) => boolean) | undefined;
    /** The field of the tooltip to apply to the cell.     */
    tooltipField: string | undefined;
    /** Callback that should return the string to use for a tooltip, `tooltipField` takes precedence if set.
     * If using a custom `tooltipComponent` you may return any custom value to be passed to your tooltip component.     */
    tooltipValueGetter: ((params: ITooltipParams) => string | any) | undefined;
    /** `boolean` or `Function`. Set to `true` (or return `true` from function) to render a selection checkbox in the column. Default: `false`     */
    checkboxSelection: boolean | CheckboxSelectionCallback | undefined;
    /** Icons to use inside the column instead of the grid's default icons. Leave undefined to use defaults.     */
    icons: {
        [key: string]: Function | string;
    } | undefined;
    /** Set to `true` if this column is not navigable (i.e. cannot be tabbed into), otherwise `false`.
     * Can also be a callback function to have different rows navigable.
     * Default: `false`     */
    suppressNavigable: boolean | SuppressNavigableCallback | undefined;
    /** Allows the user to suppress certain keyboard events in the grid cell. Default: `false`     */
    suppressKeyboardEvent: ((params: SuppressKeyboardEventParams) => boolean) | undefined;
    /** Pasting is on by default as long as cells are editable (non-editable cells cannot be modified, even with a paste operation).
     * Set to `true` turn paste operations off.     */
    suppressPaste: boolean | SuppressPasteCallback | undefined;
    /** Set to true to prevent the fillHandle from being rendered in any cell that belongs to this column     */
    suppressFillHandle: boolean | undefined;
    /** Set to `true` for this column to be hidden. Default: `false`     */
    hide: boolean | undefined;
    /** Same as `hide`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialHide: boolean | undefined;
    /** Set to `true` to block making column visible / hidden via the UI (API will still work). Default: `false`     */
    lockVisible: boolean | undefined;
    /** Lock a column to position to `'left'` or`'right'` to always have this column displayed in that position. true is treated as `'left'`     */
    lockPosition: boolean | 'left' | 'right' | undefined;
    /** Set to `true` if you do not want this column to be movable via dragging. Default: `false`     */
    suppressMovable: boolean | undefined;
    /** Set to `true` if this column is editable, otherwise `false`. Can also be a function to have different rows editable. Default: `false`     */
    editable: boolean | EditableCallback | undefined;
    /** Function or expression. Sets the value into your data for saving. Return `true` if the data changed.     */
    valueSetter: string | ValueSetterFunc | undefined;
    /** Function or expression. Parses the value for saving.     */
    valueParser: string | ValueParserFunc | undefined;
    /** Provide your own cell editor component for this column's cells.
     * See [Cell Editor](https://www.ag-grid.com/javascript-data-grid/component-cell-editor/) for framework specific implementation detail.     */
    cellEditor: any;
    /** @deprecated As of v27, use `cellEditor` for framework components too.
     */
    cellEditorFramework: any;
    /** Params to be passed to the `cellEditor` component.     */
    cellEditorParams: any;
    /** Callback to select which cell editor to be used for a given row within the same column.     */
    cellEditorSelector: CellEditorSelectorFunc | undefined;
    /** Set to `true` to have cells under this column enter edit mode after single click. Default: `false`     */
    singleClickEdit: boolean | undefined;
    /** @deprecated use `valueSetter` instead
     */
    newValueHandler: ((params: NewValueParams) => boolean) | undefined;
    /** Set to `true`, to have the cell editor appear in a popup.     */
    cellEditorPopup: boolean | undefined;
    /** Set the position for the popup cell editor. Possible values are
     *   - `over` Popup will be positioned over the cell
     *   - `under` Popup will be positioned below the cell leaving the cell value visible.
     *
     * Default: `over`.     */
    cellEditorPopupPosition: string | undefined;
    /** Callback for after the value of a cell has changed, either due to editing or the application calling `api.setValue()`.     */
    onCellValueChanged: ((event: NewValueParams) => void) | undefined;
    /** Callback called when a cell is clicked.     */
    onCellClicked: ((event: CellClickedEvent) => void) | undefined;
    /** Callback called when a cell is double clicked.     */
    onCellDoubleClicked: ((event: CellDoubleClickedEvent) => void) | undefined;
    /** Callback called when a cell is right clicked.     */
    onCellContextMenu: ((event: CellContextMenuEvent) => void) | undefined;
    /** A function to tell the grid what quick filter text to use for this column if you don't want to use the default (which is calling `toString` on the value).     */
    getQuickFilterText: ((params: GetQuickFilterTextParams) => string) | undefined;
    /** Function or expression. Gets the value for filtering purposes.     */
    filterValueGetter: string | ValueGetterFunc | undefined;
    /** Whether to display a floating filter for this column. Default: `false`     */
    floatingFilter: boolean | undefined;
    /**     */
    /** The custom header component to be used for rendering the component header. If none specified the default AG Grid header component is used.
         * See [Header Component](https://www.ag-grid.com/javascript-data-grid/component-header/) for framework specific implementation detail.     */
    headerComponent: any;
    /** @deprecated As of v27, use `headerComponent` for framework components too.
     */
    headerComponentFramework: any;
    /** The parameters to be passed to the `headerComponent`.     */
    headerComponentParams: any;
    /** Set to an array containing zero, one or many of the following options: `'filterMenuTab' | 'generalMenuTab' | 'columnsMenuTab'`.
     * This is used to figure out which menu tabs are present and in which order the tabs are shown.     */
    menuTabs: string[] | undefined;
    /** Params used to change the behaviour and appearance of the Columns Menu tab.     */
    columnsMenuParams: ColumnsMenuParams | undefined;
    /** Set to `true` if no menu should be shown for this column header. Default: `false`     */
    suppressMenu: boolean | undefined;
    /** If `true` or the callback returns `true`, a 'select all' checkbox will be put into the header.     */
    headerCheckboxSelection: boolean | HeaderCheckboxSelectionCallback | undefined;
    /** If `true`, the header checkbox selection will only select filtered items.     */
    headerCheckboxSelectionFilteredOnly: boolean | undefined;
    /** Defines the chart data type that should be used for a column.     */
    chartDataType: 'category' | 'series' | 'time' | 'excluded' | undefined;
    /** Pin a column to one side: `right` or `left`. A value of `true` is converted to `'left'`.     */
    pinned: boolean | string | null | undefined;
    /** Same as `pinned`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialPinned: boolean | string | undefined;
    /** Set to true to block the user pinning the column, the column can only be pinned via definitions or API. Default: `false`     */
    lockPinned: boolean | undefined;
    /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
     */
    pinnedRowCellRenderer: {
        new (): ICellRendererComp;
    } | ICellRendererFunc | string | undefined;
    /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
     */
    pinnedRowCellRendererFramework: any;
    /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
     */
    pinnedRowCellRendererParams: any;
    /** @deprecated Use valueFormatter for pinned rows, and check params.node.rowPinned.
     */
    pinnedRowValueFormatter: string | ValueFormatterFunc | undefined;
    /** Set to true to pivot by this column.     */
    pivot: boolean | undefined;
    /** Same as `pivot`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialPivot: boolean | undefined;
    /** Set this in columns you want to pivot by.
     * If only pivoting by one column, set this to any number (e.g. `0`).
     * If pivoting by multiple columns, set this to where you want this column to be in the order of pivots (e.g. `0` for first, `1` for second, and so on).     */
    pivotIndex: number | null | undefined;
    /** Same as `pivotIndex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialPivotIndex: number | undefined;
    /** Comparator to use when ordering the pivot columns, when this column is used to pivot on.
     * The values will always be strings, as the pivot service uses strings as keys for the pivot groups.     */
    pivotComparator: ((valueA: string, valueB: string) => number) | undefined;
    /** Set to `true` if you want to be able to pivot by this column via the GUI. This will not block the API or properties being used to achieve pivot. Default: `false`     */
    enablePivot: boolean | undefined;
    /** An object of css values / or function returning an object of css values for a particular cell.     */
    cellStyle: CellStyle | CellStyleFunc | undefined;
    /** Class to use for the cell. Can be string, array of strings, or function that returns a string or array of strings.     */
    cellClass: string | string[] | CellClassFunc | undefined;
    /** Rules which can be applied to include certain CSS classes.     */
    cellClassRules: CellClassRules | undefined;
    /** Provide your own cell Renderer component for this column's cells.
     * See [Cell Renderer](https://www.ag-grid.com/javascript-data-grid/component-cell-renderer/) for framework specific implementation details.     */
    cellRenderer: any;
    /** @deprecated As of v27, use `cellRenderer` for framework components too.
     */
    cellRendererFramework: any;
    /** Params to be passed to the `cellRenderer` component.     */
    cellRendererParams: any;
    /** Callback to select which cell renderer to be used for a given row within the same column.     */
    cellRendererSelector: CellRendererSelectorFunc | undefined;
    /** Set to `true` to have the grid calculate the height of a row based on contents of this column. Default: `false`     */
    autoHeight: boolean | undefined;
    /** Set to `true` to have the text wrap inside the cell - typically used with `autoHeight`. Default: `false`     */
    wrapText: boolean | undefined;
    /** Set to `true` to flash a cell when it's refreshed. Default: `false`     */
    enableCellChangeFlash: boolean | undefined;
    /** Set to `true` to prevent this column from flashing on changes. Only applicable if cell flashing is turned on for the grid. Default: `false`     */
    suppressCellFlash: boolean | undefined;
    /** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow row dragging. Default: `false`     */
    rowDrag: boolean | RowDragCallback | undefined;
    /** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.
     * If this callback is not set, the current cell value will be used.     */
    rowDragText: ((params: IRowDragItem, dragItemCount: number) => string) | undefined;
    /** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow dragging for native drag and drop. Default: `false`     */
    dndSource: boolean | DndSourceCallback | undefined;
    /** Function to allow custom drag functionality for native drag and drop.     */
    dndSourceOnRowDrag: ((params: DndSourceOnRowDragParams) => void) | undefined;
    /** Set to `true` to row group by this column. Default: `false`     */
    rowGroup: boolean | undefined;
    /** Same as `rowGroup`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialRowGroup: boolean | undefined;
    /** Set this in columns you want to group by.
     * If only grouping by one column, set this to any number (e.g. `0`).
     * If grouping by multiple columns, set this to where you want this column to be in the group (e.g. `0` for first, `1` for second, and so on).     */
    rowGroupIndex: number | null | undefined;
    /** Same as `rowGroupIndex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialRowGroupIndex: number | undefined;
    /** Set to `true` if you want to be able to row group by this column via the GUI.
     * This will not block the API or properties being used to achieve row grouping.
     * Default: `false`     */
    enableRowGroup: boolean | undefined;
    /** Set to `true` if you want to be able to aggregate by this column via the GUI.
     * This will not block the API or properties being used to achieve aggregation.
     * Default: `false`     */
    enableValue: boolean | undefined;
    /** Name of function to use for aggregation. You can also provide your own agg function.     */
    aggFunc: string | IAggFunc | null | undefined;
    /** Same as `aggFunc`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialAggFunc: string | IAggFunc | undefined;
    /** Aggregation functions allowed on this column e.g. `['sum', 'avg']`.
     * If missing, all installed functions are allowed.
     * This will only restrict what the GUI allows a user to select, it does not impact when you set a function via the API.     */
    allowedAggFuncs: string[] | undefined;
    /** Set to true to have the grid place the values for the group into the cell, or put the name of a grouped column to just show that group.     */
    showRowGroup: string | boolean | undefined;
    /** Set to `true` to allow sorting on this column. Default: `false`     */
    sortable: boolean | undefined;
    /** If sorting by default, set it here. Set to `asc` or `desc`.     */
    sort: 'asc' | 'desc' | null | undefined;
    /** Same as `sort`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialSort: 'asc' | 'desc' | null | undefined;
    /** If sorting more than one column by default, specifies order in which the sorting should be applied.     */
    sortIndex: number | null | undefined;
    /** Same as `sortIndex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialSortIndex: number | undefined;
    /** Array defining the order in which sorting occurs (if sorting is enabled). An array with any of the following in any order `['asc','desc',null]`     */
    sortingOrder: ('asc' | 'desc' | null)[] | undefined;
    /** Comparator function for custom sorting.     */
    comparator: ((valueA: any, valueB: any, nodeA: RowNode, nodeB: RowNode, isInverted: boolean) => number) | undefined;
    /** Set to `true` if you want the unsorted icon to be shown when no sort is applied to this column. Default: `false`     */
    unSortIcon: boolean | undefined;
    /** @deprecated since v24 - use sortIndex instead
     */
    sortedAt: number | undefined;
    /** By default, each cell will take up the width of one column. You can change this behaviour to allow cells to span multiple columns.     */
    colSpan: ((params: ColSpanParams) => number) | undefined;
    /** By default, each cell will take up the height of one row. You can change this behaviour to allow cells to span multiple rows.     */
    rowSpan: ((params: RowSpanParams) => number) | undefined;
    /** Initial width in pixels for the cell.     */
    width: number | undefined;
    /** Same as `width`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialWidth: number | undefined;
    /** Minimum width in pixels for the cell.     */
    minWidth: number | undefined;
    /** Maximum width in pixels for the cell.     */
    maxWidth: number | undefined;
    /** Used instead of `width` when the goal is to fill the remaining empty space of the grid.     */
    flex: number | undefined;
    /** Same as `flex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialFlex: number | undefined;
    /** Set to `true` to allow this column should be resized. Default: `false`     */
    resizable: boolean | undefined;
    /** Set to `true` if you want this column's width to be fixed during 'size to fit' operations. Default: `false`     */
    suppressSizeToFit: boolean | undefined;
    /** Set to `true` if you do not want this column to be auto-resizable by double clicking it's edge. Default: `false`     */
    suppressAutoSize: boolean | undefined;
    static ngAcceptInputType_suppressCellFlash: boolean | null | '';
    static ngAcceptInputType_suppressColumnsToolPanel: boolean | null | '';
    static ngAcceptInputType_suppressFiltersToolPanel: boolean | null | '';
    static ngAcceptInputType_openByDefault: boolean | null | '';
    static ngAcceptInputType_marryChildren: boolean | null | '';
    static ngAcceptInputType_hide: boolean | null | '';
    static ngAcceptInputType_initialHide: boolean | null | '';
    static ngAcceptInputType_rowGroup: boolean | null | '';
    static ngAcceptInputType_initialRowGroup: boolean | null | '';
    static ngAcceptInputType_pivot: boolean | null | '';
    static ngAcceptInputType_initialPivot: boolean | null | '';
    static ngAcceptInputType_checkboxSelection: boolean | null | '';
    static ngAcceptInputType_headerCheckboxSelection: boolean | null | '';
    static ngAcceptInputType_headerCheckboxSelectionFilteredOnly: boolean | null | '';
    static ngAcceptInputType_suppressMenu: boolean | null | '';
    static ngAcceptInputType_suppressMovable: boolean | null | '';
    static ngAcceptInputType_lockPosition: boolean | null | '';
    static ngAcceptInputType_lockVisible: boolean | null | '';
    static ngAcceptInputType_lockPinned: boolean | null | '';
    static ngAcceptInputType_unSortIcon: boolean | null | '';
    static ngAcceptInputType_suppressSizeToFit: boolean | null | '';
    static ngAcceptInputType_suppressAutoSize: boolean | null | '';
    static ngAcceptInputType_enableRowGroup: boolean | null | '';
    static ngAcceptInputType_enablePivot: boolean | null | '';
    static ngAcceptInputType_enableValue: boolean | null | '';
    static ngAcceptInputType_editable: boolean | null | '';
    static ngAcceptInputType_suppressPaste: boolean | null | '';
    static ngAcceptInputType_suppressNavigable: boolean | null | '';
    static ngAcceptInputType_enableCellChangeFlash: boolean | null | '';
    static ngAcceptInputType_rowDrag: boolean | null | '';
    static ngAcceptInputType_dndSource: boolean | null | '';
    static ngAcceptInputType_autoHeight: boolean | null | '';
    static ngAcceptInputType_wrapText: boolean | null | '';
    static ngAcceptInputType_sortable: boolean | null | '';
    static ngAcceptInputType_resizable: boolean | null | '';
    static ngAcceptInputType_singleClickEdit: boolean | null | '';
    static ngAcceptInputType_floatingFilter: boolean | null | '';
    static ngAcceptInputType_cellEditorPopup: boolean | null | '';
    static ngAcceptInputType_suppressFillHandle: boolean | null | '';
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgGridColumn>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<AgGridColumn, "ag-grid-column", never, {
    "filterFramework": "filterFramework";
    "filterParams": "filterParams";
    "floatingFilterComponent": "floatingFilterComponent";
    "floatingFilterComponentParams": "floatingFilterComponentParams";
    "floatingFilterComponentFramework": "floatingFilterComponentFramework";
    "floatingFilterFramework": "floatingFilterFramework";
    "filter": "filter";
    "headerName": "headerName";
    "headerValueGetter": "headerValueGetter";
    "headerTooltip": "headerTooltip";
    "headerClass": "headerClass";
    "suppressHeaderKeyboardEvent": "suppressHeaderKeyboardEvent";
    "columnGroupShow": "columnGroupShow";
    "toolPanelClass": "toolPanelClass";
    "suppressColumnsToolPanel": "suppressColumnsToolPanel";
    "suppressFiltersToolPanel": "suppressFiltersToolPanel";
    "tooltipComponent": "tooltipComponent";
    "tooltipComponentFramework": "tooltipComponentFramework";
    "tooltipComponentParams": "tooltipComponentParams";
    "children": "children";
    "groupId": "groupId";
    "openByDefault": "openByDefault";
    "marryChildren": "marryChildren";
    "headerGroupComponent": "headerGroupComponent";
    "headerGroupComponentFramework": "headerGroupComponentFramework";
    "headerGroupComponentParams": "headerGroupComponentParams";
    "colId": "colId";
    "field": "field";
    "type": "type";
    "valueGetter": "valueGetter";
    "valueFormatter": "valueFormatter";
    "refData": "refData";
    "keyCreator": "keyCreator";
    "equals": "equals";
    "tooltipField": "tooltipField";
    "tooltipValueGetter": "tooltipValueGetter";
    "checkboxSelection": "checkboxSelection";
    "icons": "icons";
    "suppressNavigable": "suppressNavigable";
    "suppressKeyboardEvent": "suppressKeyboardEvent";
    "suppressPaste": "suppressPaste";
    "suppressFillHandle": "suppressFillHandle";
    "hide": "hide";
    "initialHide": "initialHide";
    "lockVisible": "lockVisible";
    "lockPosition": "lockPosition";
    "suppressMovable": "suppressMovable";
    "editable": "editable";
    "valueSetter": "valueSetter";
    "valueParser": "valueParser";
    "cellEditor": "cellEditor";
    "cellEditorFramework": "cellEditorFramework";
    "cellEditorParams": "cellEditorParams";
    "cellEditorSelector": "cellEditorSelector";
    "singleClickEdit": "singleClickEdit";
    "newValueHandler": "newValueHandler";
    "cellEditorPopup": "cellEditorPopup";
    "cellEditorPopupPosition": "cellEditorPopupPosition";
    "onCellValueChanged": "onCellValueChanged";
    "onCellClicked": "onCellClicked";
    "onCellDoubleClicked": "onCellDoubleClicked";
    "onCellContextMenu": "onCellContextMenu";
    "getQuickFilterText": "getQuickFilterText";
    "filterValueGetter": "filterValueGetter";
    "floatingFilter": "floatingFilter";
    "headerComponent": "headerComponent";
    "headerComponentFramework": "headerComponentFramework";
    "headerComponentParams": "headerComponentParams";
    "menuTabs": "menuTabs";
    "columnsMenuParams": "columnsMenuParams";
    "suppressMenu": "suppressMenu";
    "headerCheckboxSelection": "headerCheckboxSelection";
    "headerCheckboxSelectionFilteredOnly": "headerCheckboxSelectionFilteredOnly";
    "chartDataType": "chartDataType";
    "pinned": "pinned";
    "initialPinned": "initialPinned";
    "lockPinned": "lockPinned";
    "pinnedRowCellRenderer": "pinnedRowCellRenderer";
    "pinnedRowCellRendererFramework": "pinnedRowCellRendererFramework";
    "pinnedRowCellRendererParams": "pinnedRowCellRendererParams";
    "pinnedRowValueFormatter": "pinnedRowValueFormatter";
    "pivot": "pivot";
    "initialPivot": "initialPivot";
    "pivotIndex": "pivotIndex";
    "initialPivotIndex": "initialPivotIndex";
    "pivotComparator": "pivotComparator";
    "enablePivot": "enablePivot";
    "cellStyle": "cellStyle";
    "cellClass": "cellClass";
    "cellClassRules": "cellClassRules";
    "cellRenderer": "cellRenderer";
    "cellRendererFramework": "cellRendererFramework";
    "cellRendererParams": "cellRendererParams";
    "cellRendererSelector": "cellRendererSelector";
    "autoHeight": "autoHeight";
    "wrapText": "wrapText";
    "enableCellChangeFlash": "enableCellChangeFlash";
    "suppressCellFlash": "suppressCellFlash";
    "rowDrag": "rowDrag";
    "rowDragText": "rowDragText";
    "dndSource": "dndSource";
    "dndSourceOnRowDrag": "dndSourceOnRowDrag";
    "rowGroup": "rowGroup";
    "initialRowGroup": "initialRowGroup";
    "rowGroupIndex": "rowGroupIndex";
    "initialRowGroupIndex": "initialRowGroupIndex";
    "enableRowGroup": "enableRowGroup";
    "enableValue": "enableValue";
    "aggFunc": "aggFunc";
    "initialAggFunc": "initialAggFunc";
    "allowedAggFuncs": "allowedAggFuncs";
    "showRowGroup": "showRowGroup";
    "sortable": "sortable";
    "sort": "sort";
    "initialSort": "initialSort";
    "sortIndex": "sortIndex";
    "initialSortIndex": "initialSortIndex";
    "sortingOrder": "sortingOrder";
    "comparator": "comparator";
    "unSortIcon": "unSortIcon";
    "sortedAt": "sortedAt";
    "colSpan": "colSpan";
    "rowSpan": "rowSpan";
    "width": "width";
    "initialWidth": "initialWidth";
    "minWidth": "minWidth";
    "maxWidth": "maxWidth";
    "flex": "flex";
    "initialFlex": "initialFlex";
    "resizable": "resizable";
    "suppressSizeToFit": "suppressSizeToFit";
    "suppressAutoSize": "suppressAutoSize";
}, {}, ["childColumns"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWctZ3JpZC1jb2x1bW4uY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImFnLWdyaWQtY29sdW1uLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdXQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENlbGxDbGFzc0Z1bmMsIENlbGxDbGFzc1J1bGVzLCBDZWxsQ2xpY2tlZEV2ZW50LCBDZWxsQ29udGV4dE1lbnVFdmVudCwgQ2VsbERvdWJsZUNsaWNrZWRFdmVudCwgQ2VsbEVkaXRvclNlbGVjdG9yRnVuYywgQ2VsbFJlbmRlcmVyU2VsZWN0b3JGdW5jLCBDZWxsU3R5bGUsIENlbGxTdHlsZUZ1bmMsIENoZWNrYm94U2VsZWN0aW9uQ2FsbGJhY2ssIENvbERlZiwgQ29sR3JvdXBEZWYsIENvbFNwYW5QYXJhbXMsIENvbHVtbnNNZW51UGFyYW1zLCBEbmRTb3VyY2VDYWxsYmFjaywgRG5kU291cmNlT25Sb3dEcmFnUGFyYW1zLCBFZGl0YWJsZUNhbGxiYWNrLCBHZXRRdWlja0ZpbHRlclRleHRQYXJhbXMsIEhlYWRlckNoZWNrYm94U2VsZWN0aW9uQ2FsbGJhY2ssIEhlYWRlckNsYXNzLCBIZWFkZXJWYWx1ZUdldHRlckZ1bmMsIElBZ2dGdW5jLCBJQ2VsbFJlbmRlcmVyQ29tcCwgSUNlbGxSZW5kZXJlckZ1bmMsIElSb3dEcmFnSXRlbSwgSVRvb2x0aXBQYXJhbXMsIEtleUNyZWF0b3JQYXJhbXMsIE5ld1ZhbHVlUGFyYW1zLCBSb3dEcmFnQ2FsbGJhY2ssIFJvd05vZGUsIFJvd1NwYW5QYXJhbXMsIFN1cHByZXNzSGVhZGVyS2V5Ym9hcmRFdmVudFBhcmFtcywgU3VwcHJlc3NLZXlib2FyZEV2ZW50UGFyYW1zLCBTdXBwcmVzc05hdmlnYWJsZUNhbGxiYWNrLCBTdXBwcmVzc1Bhc3RlQ2FsbGJhY2ssIFRvb2xQYW5lbENsYXNzLCBWYWx1ZUZvcm1hdHRlckZ1bmMsIFZhbHVlR2V0dGVyRnVuYywgVmFsdWVQYXJzZXJGdW5jLCBWYWx1ZVNldHRlckZ1bmMgfSBmcm9tIFwiYWctZ3JpZC1jb21tdW5pdHlcIjtcbmltcG9ydCB7IFF1ZXJ5TGlzdCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ0dyaWRDb2x1bW4ge1xuICAgIGNoaWxkQ29sdW1uczogUXVlcnlMaXN0PEFnR3JpZENvbHVtbj47XG4gICAgaGFzQ2hpbGRDb2x1bW5zKCk6IGJvb2xlYW47XG4gICAgdG9Db2xEZWYoKTogQ29sRGVmO1xuICAgIHByaXZhdGUgZ2V0Q2hpbGRDb2xEZWZzO1xuICAgIHByaXZhdGUgY3JlYXRlQ29sRGVmRnJvbUdyaWRDb2x1bW47XG4gICAgZmlsdGVyRnJhbWV3b3JrOiBhbnk7XG4gICAgZmlsdGVyUGFyYW1zOiBhbnk7XG4gICAgZmxvYXRpbmdGaWx0ZXJDb21wb25lbnQ6IGFueTtcbiAgICBmbG9hdGluZ0ZpbHRlckNvbXBvbmVudFBhcmFtczogYW55O1xuICAgIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50RnJhbWV3b3JrOiBhbnk7XG4gICAgZmxvYXRpbmdGaWx0ZXJGcmFtZXdvcms6IGFueTtcbiAgICBmaWx0ZXI6IGFueTtcbiAgICAvKiogVGhlIG5hbWUgdG8gcmVuZGVyIGluIHRoZSBjb2x1bW4gaGVhZGVyLiBJZiBub3Qgc3BlY2lmaWVkIGFuZCBmaWVsZCBpcyBzcGVjaWZpZWQsIHRoZSBmaWVsZCBuYW1lIHdpbGwgYmUgdXNlZCBhcyB0aGUgaGVhZGVyIG5hbWUuICAgICAqL1xuICAgIGhlYWRlck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gR2V0cyB0aGUgdmFsdWUgZm9yIGRpc3BsYXkgaW4gdGhlIGhlYWRlci4gICAgICovXG4gICAgaGVhZGVyVmFsdWVHZXR0ZXI6IHN0cmluZyB8IEhlYWRlclZhbHVlR2V0dGVyRnVuYyB8IHVuZGVmaW5lZDtcbiAgICAvKiogVG9vbHRpcCBmb3IgdGhlIGNvbHVtbiBoZWFkZXIgICAgICovXG4gICAgaGVhZGVyVG9vbHRpcDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBDU1MgY2xhc3MgdG8gdXNlIGZvciB0aGUgaGVhZGVyIGNlbGwuIENhbiBiZSBhIHN0cmluZywgYXJyYXkgb2Ygc3RyaW5ncywgb3IgZnVuY3Rpb24uICAgICAqL1xuICAgIGhlYWRlckNsYXNzOiBIZWFkZXJDbGFzcyB8IHVuZGVmaW5lZDtcbiAgICAvKiogU3VwcHJlc3MgdGhlIGdyaWQgdGFraW5nIGFjdGlvbiBmb3IgdGhlIHJlbGV2YW50IGtleWJvYXJkIGV2ZW50IHdoZW4gYSBoZWFkZXIgaXMgZm9jdXNlZC4gICAgICovXG4gICAgc3VwcHJlc3NIZWFkZXJLZXlib2FyZEV2ZW50OiAoKHBhcmFtczogU3VwcHJlc3NIZWFkZXJLZXlib2FyZEV2ZW50UGFyYW1zKSA9PiBib29sZWFuKSB8IHVuZGVmaW5lZDtcbiAgICAvKiogV2hldGhlciB0byBzaG93IHRoZSBjb2x1bW4gd2hlbiB0aGUgZ3JvdXAgaXMgb3BlbiAvIGNsb3NlZC4gICAgICovXG4gICAgY29sdW1uR3JvdXBTaG93OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqIENTUyBjbGFzcyB0byB1c2UgZm9yIHRoZSB0b29sIHBhbmVsIGNlbGwuIENhbiBiZSBhIHN0cmluZywgYXJyYXkgb2Ygc3RyaW5ncywgb3IgZnVuY3Rpb24uICAgICAqL1xuICAgIHRvb2xQYW5lbENsYXNzOiBUb29sUGFuZWxDbGFzcyB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB5b3UgZG8gbm90IHdhbnQgdGhpcyBjb2x1bW4gb3IgZ3JvdXAgdG8gYXBwZWFyIGluIHRoZSBDb2x1bW5zIFRvb2wgUGFuZWwuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgc3VwcHJlc3NDb2x1bW5zVG9vbFBhbmVsOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSBkbyBub3Qgd2FudCB0aGlzIGNvbHVtbiAoZmlsdGVyKSBvciBncm91cCAoZmlsdGVyIGdyb3VwKSB0byBhcHBlYXIgaW4gdGhlIEZpbHRlcnMgVG9vbCBQYW5lbC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBzdXBwcmVzc0ZpbHRlcnNUb29sUGFuZWw6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFByb3ZpZGUgeW91ciBvd24gdG9vbHRpcCBjb21wb25lbnQgZm9yIHRoZSBjb2x1bW4uXG4gICAgICogU2VlIFtUb29sdGlwIENvbXBvbmVudF0oaHR0cHM6Ly93d3cuYWctZ3JpZC5jb20vamF2YXNjcmlwdC1kYXRhLWdyaWQvY29tcG9uZW50LXRvb2x0aXAvKSBmb3IgZnJhbWV3b3JrIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGRldGFpbHMuICAgICAqL1xuICAgIHRvb2x0aXBDb21wb25lbnQ6IGFueTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgQXMgb2YgdjI3LCB1c2UgYHRvb2x0aXBDb21wb25lbnRgIGZvciBmcmFtZXdvcmsgY29tcG9uZW50cyB0b28uXG4gICAgICovXG4gICAgdG9vbHRpcENvbXBvbmVudEZyYW1ld29yazogYW55O1xuICAgIC8qKiBUaGUgcGFyYW1zIHVzZWQgdG8gY29uZmlndXJlIGB0b29sdGlwQ29tcG9uZW50YC4gICAgICovXG4gICAgdG9vbHRpcENvbXBvbmVudFBhcmFtczogYW55O1xuICAgIC8qKiBBIGxpc3QgY29udGFpbmluZyBhIG1peCBvZiBjb2x1bW5zIGFuZCBjb2x1bW4gZ3JvdXBzLiAgICAgKi9cbiAgICBjaGlsZHJlbjogKENvbERlZiB8IENvbEdyb3VwRGVmKVtdIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBUaGUgdW5pcXVlIElEIHRvIGdpdmUgdGhlIGNvbHVtbi4gVGhpcyBpcyBvcHRpb25hbC4gSWYgbWlzc2luZywgYSB1bmlxdWUgSUQgd2lsbCBiZSBnZW5lcmF0ZWQuIFRoaXMgSUQgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgY29sdW1uIGdyb3VwIGluIHRoZSBjb2x1bW4gQVBJLiAgICAgKi9cbiAgICBncm91cElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgdGhpcyBncm91cCBzaG91bGQgYmUgb3BlbmVkIGJ5IGRlZmF1bHQuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgb3BlbkJ5RGVmYXVsdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBrZWVwIGNvbHVtbnMgaW4gdGhpcyBncm91cCBiZXNpZGUgZWFjaCBvdGhlciBpbiB0aGUgZ3JpZC4gTW92aW5nIHRoZSBjb2x1bW5zIG91dHNpZGUgb2YgdGhlIGdyb3VwIChhbmQgaGVuY2UgYnJlYWtpbmcgdGhlIGdyb3VwKSBpcyBub3QgYWxsb3dlZC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBtYXJyeUNoaWxkcmVuOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBUaGUgY3VzdG9tIGhlYWRlciBncm91cCBjb21wb25lbnQgdG8gYmUgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBjb21wb25lbnQgaGVhZGVyLiBJZiBub25lIHNwZWNpZmllZCB0aGUgZGVmYXVsdCBBRyBHcmlkIGlzIHVzZWQuXG4gICAgICogU2VlIFtIZWFkZXIgR3JvdXAgQ29tcG9uZW50XShodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9jb21wb25lbnQtaGVhZGVyLyNoZWFkZXItZ3JvdXAtY29tcG9uZW50cy8pIGZvciBmcmFtZXdvcmsgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gZGV0YWlscy4gICAgICovXG4gICAgaGVhZGVyR3JvdXBDb21wb25lbnQ6IGFueTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgQXMgb2YgdjI3LCB1c2UgYGhlYWRlckdyb3VwQ29tcG9uZW50YCBmb3IgZnJhbWV3b3JrIGNvbXBvbmVudHMgdG9vLlxuICAgICAqL1xuICAgIGhlYWRlckdyb3VwQ29tcG9uZW50RnJhbWV3b3JrOiBhbnk7XG4gICAgLyoqIFRoZSBwYXJhbXMgdXNlZCB0byBjb25maWd1cmUgdGhlIGBoZWFkZXJHcm91cENvbXBvbmVudGAuICAgICAqL1xuICAgIGhlYWRlckdyb3VwQ29tcG9uZW50UGFyYW1zOiBhbnk7XG4gICAgLyoqIFRoZSB1bmlxdWUgSUQgdG8gZ2l2ZSB0aGUgY29sdW1uLiBUaGlzIGlzIG9wdGlvbmFsLiBJZiBtaXNzaW5nLCB0aGUgSUQgd2lsbCBkZWZhdWx0IHRvIHRoZSBmaWVsZC5cbiAgICAgKiBJZiBib3RoIGZpZWxkIGFuZCBjb2xJZCBhcmUgbWlzc2luZywgYSB1bmlxdWUgSUQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAgICogVGhpcyBJRCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBjb2x1bW4gaW4gdGhlIEFQSSBmb3Igc29ydGluZywgZmlsdGVyaW5nIGV0Yy4gICAgICovXG4gICAgY29sSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogVGhlIGZpZWxkIG9mIHRoZSByb3cgdG8gZ2V0IHRoZSBjZWxscyBkYXRhIGZyb20gICAgICovXG4gICAgZmllbGQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogQSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBgQ29sdW1uVHlwZWAga2V5cyB3aGljaCBjYW4gYmUgdXNlZCBhcyBhIHRlbXBsYXRlIGZvciBhIGNvbHVtbi5cbiAgICAgKiBUaGlzIGhlbHBzIHRvIHJlZHVjZSBkdXBsaWNhdGlvbiBvZiBwcm9wZXJ0aWVzIHdoZW4geW91IGhhdmUgYSBsb3Qgb2YgY29tbW9uIGNvbHVtbiBwcm9wZXJ0aWVzLiAgICAgKi9cbiAgICB0eXBlOiBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gR2V0cyB0aGUgdmFsdWUgZnJvbSB5b3VyIGRhdGEgZm9yIGRpc3BsYXkuICAgICAqL1xuICAgIHZhbHVlR2V0dGVyOiBzdHJpbmcgfCBWYWx1ZUdldHRlckZ1bmMgfCB1bmRlZmluZWQ7XG4gICAgLyoqIEEgZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0byBmb3JtYXQgYSB2YWx1ZSwgc2hvdWxkIHJldHVybiBhIHN0cmluZy4gTm90IHVzZWQgZm9yIENTViBleHBvcnQgb3IgY29weSB0byBjbGlwYm9hcmQsIG9ubHkgZm9yIFVJIGNlbGwgcmVuZGVyaW5nLiAgICAgKi9cbiAgICB2YWx1ZUZvcm1hdHRlcjogc3RyaW5nIHwgVmFsdWVGb3JtYXR0ZXJGdW5jIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBQcm92aWRlZCBhIHJlZmVyZW5jZSBkYXRhIG1hcCB0byBiZSB1c2VkIHRvIG1hcCBjb2x1bW4gdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgdmFsdWUgZnJvbSB0aGUgbWFwLiAgICAgKi9cbiAgICByZWZEYXRhOiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IHN0cmluZztcbiAgICB9IHwgdW5kZWZpbmVkO1xuICAgIC8qKiBGdW5jdGlvbiB0byByZXR1cm4gYSBzdHJpbmcga2V5IGZvciBhIHZhbHVlLlxuICAgICAqIFRoaXMgc3RyaW5nIGlzIHVzZWQgZm9yIGdyb3VwaW5nLCBTZXQgZmlsdGVyaW5nLCBhbmQgc2VhcmNoaW5nIHdpdGhpbiBjZWxsIGVkaXRvciBkcm9wZG93bnMuXG4gICAgICogV2hlbiBmaWx0ZXJpbmcgYW5kIHNlYXJjaGluZyB0aGUgc3RyaW5nIGlzIGV4cG9zZWQgdG8gdGhlIHVzZXIsIHNvIG1ha2Ugc3VyZSB0byByZXR1cm4gYSBodW1hbi1yZWFkYWJsZSB2YWx1ZS4gICAgICovXG4gICAga2V5Q3JlYXRvcjogKChwYXJhbXM6IEtleUNyZWF0b3JQYXJhbXMpID0+IHN0cmluZykgfCB1bmRlZmluZWQ7XG4gICAgLyoqIEN1c3RvbSBjb21wYXJhdG9yIGZvciB2YWx1ZXMsIHVzZWQgYnkgcmVuZGVyZXIgdG8ga25vdyBpZiB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLiBDZWxscyB3aG8ncyB2YWx1ZXMgaGF2ZSBub3QgY2hhbmdlZCBkb24ndCBnZXQgcmVmcmVzaGVkLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGdyaWQgdXNlcyBgPT09YCBpcyB1c2VkIHdoaWNoIHNob3VsZCB3b3JrIGZvciBtb3N0IHVzZSBjYXNlcy4gICAgICovXG4gICAgZXF1YWxzOiAoKHZhbHVlQTogYW55LCB2YWx1ZUI6IGFueSkgPT4gYm9vbGVhbikgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFRoZSBmaWVsZCBvZiB0aGUgdG9vbHRpcCB0byBhcHBseSB0byB0aGUgY2VsbC4gICAgICovXG4gICAgdG9vbHRpcEZpZWxkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqIENhbGxiYWNrIHRoYXQgc2hvdWxkIHJldHVybiB0aGUgc3RyaW5nIHRvIHVzZSBmb3IgYSB0b29sdGlwLCBgdG9vbHRpcEZpZWxkYCB0YWtlcyBwcmVjZWRlbmNlIGlmIHNldC5cbiAgICAgKiBJZiB1c2luZyBhIGN1c3RvbSBgdG9vbHRpcENvbXBvbmVudGAgeW91IG1heSByZXR1cm4gYW55IGN1c3RvbSB2YWx1ZSB0byBiZSBwYXNzZWQgdG8geW91ciB0b29sdGlwIGNvbXBvbmVudC4gICAgICovXG4gICAgdG9vbHRpcFZhbHVlR2V0dGVyOiAoKHBhcmFtczogSVRvb2x0aXBQYXJhbXMpID0+IHN0cmluZyB8IGFueSkgfCB1bmRlZmluZWQ7XG4gICAgLyoqIGBib29sZWFuYCBvciBgRnVuY3Rpb25gLiBTZXQgdG8gYHRydWVgIChvciByZXR1cm4gYHRydWVgIGZyb20gZnVuY3Rpb24pIHRvIHJlbmRlciBhIHNlbGVjdGlvbiBjaGVja2JveCBpbiB0aGUgY29sdW1uLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xuICAgIGNoZWNrYm94U2VsZWN0aW9uOiBib29sZWFuIHwgQ2hlY2tib3hTZWxlY3Rpb25DYWxsYmFjayB8IHVuZGVmaW5lZDtcbiAgICAvKiogSWNvbnMgdG8gdXNlIGluc2lkZSB0aGUgY29sdW1uIGluc3RlYWQgb2YgdGhlIGdyaWQncyBkZWZhdWx0IGljb25zLiBMZWF2ZSB1bmRlZmluZWQgdG8gdXNlIGRlZmF1bHRzLiAgICAgKi9cbiAgICBpY29uczoge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBGdW5jdGlvbiB8IHN0cmluZztcbiAgICB9IHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHRoaXMgY29sdW1uIGlzIG5vdCBuYXZpZ2FibGUgKGkuZS4gY2Fubm90IGJlIHRhYmJlZCBpbnRvKSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICogQ2FuIGFsc28gYmUgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBoYXZlIGRpZmZlcmVudCByb3dzIG5hdmlnYWJsZS5cbiAgICAgKiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xuICAgIHN1cHByZXNzTmF2aWdhYmxlOiBib29sZWFuIHwgU3VwcHJlc3NOYXZpZ2FibGVDYWxsYmFjayB8IHVuZGVmaW5lZDtcbiAgICAvKiogQWxsb3dzIHRoZSB1c2VyIHRvIHN1cHByZXNzIGNlcnRhaW4ga2V5Ym9hcmQgZXZlbnRzIGluIHRoZSBncmlkIGNlbGwuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgc3VwcHJlc3NLZXlib2FyZEV2ZW50OiAoKHBhcmFtczogU3VwcHJlc3NLZXlib2FyZEV2ZW50UGFyYW1zKSA9PiBib29sZWFuKSB8IHVuZGVmaW5lZDtcbiAgICAvKiogUGFzdGluZyBpcyBvbiBieSBkZWZhdWx0IGFzIGxvbmcgYXMgY2VsbHMgYXJlIGVkaXRhYmxlIChub24tZWRpdGFibGUgY2VsbHMgY2Fubm90IGJlIG1vZGlmaWVkLCBldmVuIHdpdGggYSBwYXN0ZSBvcGVyYXRpb24pLlxuICAgICAqIFNldCB0byBgdHJ1ZWAgdHVybiBwYXN0ZSBvcGVyYXRpb25zIG9mZi4gICAgICovXG4gICAgc3VwcHJlc3NQYXN0ZTogYm9vbGVhbiB8IFN1cHByZXNzUGFzdGVDYWxsYmFjayB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgZmlsbEhhbmRsZSBmcm9tIGJlaW5nIHJlbmRlcmVkIGluIGFueSBjZWxsIHRoYXQgYmVsb25ncyB0byB0aGlzIGNvbHVtbiAgICAgKi9cbiAgICBzdXBwcmVzc0ZpbGxIYW5kbGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgZm9yIHRoaXMgY29sdW1uIHRvIGJlIGhpZGRlbi4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBoaWRlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTYW1lIGFzIGBoaWRlYCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIGluaXRpYWxIaWRlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIHRvIGJsb2NrIG1ha2luZyBjb2x1bW4gdmlzaWJsZSAvIGhpZGRlbiB2aWEgdGhlIFVJIChBUEkgd2lsbCBzdGlsbCB3b3JrKS4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBsb2NrVmlzaWJsZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogTG9jayBhIGNvbHVtbiB0byBwb3NpdGlvbiB0byBgJ2xlZnQnYCBvcmAncmlnaHQnYCB0byBhbHdheXMgaGF2ZSB0aGlzIGNvbHVtbiBkaXNwbGF5ZWQgaW4gdGhhdCBwb3NpdGlvbi4gdHJ1ZSBpcyB0cmVhdGVkIGFzIGAnbGVmdCdgICAgICAqL1xuICAgIGxvY2tQb3NpdGlvbjogYm9vbGVhbiB8ICdsZWZ0JyB8ICdyaWdodCcgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgY29sdW1uIHRvIGJlIG1vdmFibGUgdmlhIGRyYWdnaW5nLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xuICAgIHN1cHByZXNzTW92YWJsZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB0aGlzIGNvbHVtbiBpcyBlZGl0YWJsZSwgb3RoZXJ3aXNlIGBmYWxzZWAuIENhbiBhbHNvIGJlIGEgZnVuY3Rpb24gdG8gaGF2ZSBkaWZmZXJlbnQgcm93cyBlZGl0YWJsZS4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBlZGl0YWJsZTogYm9vbGVhbiB8IEVkaXRhYmxlQ2FsbGJhY2sgfCB1bmRlZmluZWQ7XG4gICAgLyoqIEZ1bmN0aW9uIG9yIGV4cHJlc3Npb24uIFNldHMgdGhlIHZhbHVlIGludG8geW91ciBkYXRhIGZvciBzYXZpbmcuIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGRhdGEgY2hhbmdlZC4gICAgICovXG4gICAgdmFsdWVTZXR0ZXI6IHN0cmluZyB8IFZhbHVlU2V0dGVyRnVuYyB8IHVuZGVmaW5lZDtcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gUGFyc2VzIHRoZSB2YWx1ZSBmb3Igc2F2aW5nLiAgICAgKi9cbiAgICB2YWx1ZVBhcnNlcjogc3RyaW5nIHwgVmFsdWVQYXJzZXJGdW5jIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBQcm92aWRlIHlvdXIgb3duIGNlbGwgZWRpdG9yIGNvbXBvbmVudCBmb3IgdGhpcyBjb2x1bW4ncyBjZWxscy5cbiAgICAgKiBTZWUgW0NlbGwgRWRpdG9yXShodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9jb21wb25lbnQtY2VsbC1lZGl0b3IvKSBmb3IgZnJhbWV3b3JrIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGRldGFpbC4gICAgICovXG4gICAgY2VsbEVkaXRvcjogYW55O1xuICAgIC8qKiBAZGVwcmVjYXRlZCBBcyBvZiB2MjcsIHVzZSBgY2VsbEVkaXRvcmAgZm9yIGZyYW1ld29yayBjb21wb25lbnRzIHRvby5cbiAgICAgKi9cbiAgICBjZWxsRWRpdG9yRnJhbWV3b3JrOiBhbnk7XG4gICAgLyoqIFBhcmFtcyB0byBiZSBwYXNzZWQgdG8gdGhlIGBjZWxsRWRpdG9yYCBjb21wb25lbnQuICAgICAqL1xuICAgIGNlbGxFZGl0b3JQYXJhbXM6IGFueTtcbiAgICAvKiogQ2FsbGJhY2sgdG8gc2VsZWN0IHdoaWNoIGNlbGwgZWRpdG9yIHRvIGJlIHVzZWQgZm9yIGEgZ2l2ZW4gcm93IHdpdGhpbiB0aGUgc2FtZSBjb2x1bW4uICAgICAqL1xuICAgIGNlbGxFZGl0b3JTZWxlY3RvcjogQ2VsbEVkaXRvclNlbGVjdG9yRnVuYyB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBoYXZlIGNlbGxzIHVuZGVyIHRoaXMgY29sdW1uIGVudGVyIGVkaXQgbW9kZSBhZnRlciBzaW5nbGUgY2xpY2suIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgc2luZ2xlQ2xpY2tFZGl0OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHZhbHVlU2V0dGVyYCBpbnN0ZWFkXG4gICAgICovXG4gICAgbmV3VmFsdWVIYW5kbGVyOiAoKHBhcmFtczogTmV3VmFsdWVQYXJhbXMpID0+IGJvb2xlYW4pIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgLCB0byBoYXZlIHRoZSBjZWxsIGVkaXRvciBhcHBlYXIgaW4gYSBwb3B1cC4gICAgICovXG4gICAgY2VsbEVkaXRvclBvcHVwOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdGhlIHBvc2l0aW9uIGZvciB0aGUgcG9wdXAgY2VsbCBlZGl0b3IuIFBvc3NpYmxlIHZhbHVlcyBhcmVcbiAgICAgKiAgIC0gYG92ZXJgIFBvcHVwIHdpbGwgYmUgcG9zaXRpb25lZCBvdmVyIHRoZSBjZWxsXG4gICAgICogICAtIGB1bmRlcmAgUG9wdXAgd2lsbCBiZSBwb3NpdGlvbmVkIGJlbG93IHRoZSBjZWxsIGxlYXZpbmcgdGhlIGNlbGwgdmFsdWUgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIERlZmF1bHQ6IGBvdmVyYC4gICAgICovXG4gICAgY2VsbEVkaXRvclBvcHVwUG9zaXRpb246IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogQ2FsbGJhY2sgZm9yIGFmdGVyIHRoZSB2YWx1ZSBvZiBhIGNlbGwgaGFzIGNoYW5nZWQsIGVpdGhlciBkdWUgdG8gZWRpdGluZyBvciB0aGUgYXBwbGljYXRpb24gY2FsbGluZyBgYXBpLnNldFZhbHVlKClgLiAgICAgKi9cbiAgICBvbkNlbGxWYWx1ZUNoYW5nZWQ6ICgoZXZlbnQ6IE5ld1ZhbHVlUGFyYW1zKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICAvKiogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBjZWxsIGlzIGNsaWNrZWQuICAgICAqL1xuICAgIG9uQ2VsbENsaWNrZWQ6ICgoZXZlbnQ6IENlbGxDbGlja2VkRXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBDYWxsYmFjayBjYWxsZWQgd2hlbiBhIGNlbGwgaXMgZG91YmxlIGNsaWNrZWQuICAgICAqL1xuICAgIG9uQ2VsbERvdWJsZUNsaWNrZWQ6ICgoZXZlbnQ6IENlbGxEb3VibGVDbGlja2VkRXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBDYWxsYmFjayBjYWxsZWQgd2hlbiBhIGNlbGwgaXMgcmlnaHQgY2xpY2tlZC4gICAgICovXG4gICAgb25DZWxsQ29udGV4dE1lbnU6ICgoZXZlbnQ6IENlbGxDb250ZXh0TWVudUV2ZW50KSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICAvKiogQSBmdW5jdGlvbiB0byB0ZWxsIHRoZSBncmlkIHdoYXQgcXVpY2sgZmlsdGVyIHRleHQgdG8gdXNlIGZvciB0aGlzIGNvbHVtbiBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgKHdoaWNoIGlzIGNhbGxpbmcgYHRvU3RyaW5nYCBvbiB0aGUgdmFsdWUpLiAgICAgKi9cbiAgICBnZXRRdWlja0ZpbHRlclRleHQ6ICgocGFyYW1zOiBHZXRRdWlja0ZpbHRlclRleHRQYXJhbXMpID0+IHN0cmluZykgfCB1bmRlZmluZWQ7XG4gICAgLyoqIEZ1bmN0aW9uIG9yIGV4cHJlc3Npb24uIEdldHMgdGhlIHZhbHVlIGZvciBmaWx0ZXJpbmcgcHVycG9zZXMuICAgICAqL1xuICAgIGZpbHRlclZhbHVlR2V0dGVyOiBzdHJpbmcgfCBWYWx1ZUdldHRlckZ1bmMgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFdoZXRoZXIgdG8gZGlzcGxheSBhIGZsb2F0aW5nIGZpbHRlciBmb3IgdGhpcyBjb2x1bW4uIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgZmxvYXRpbmdGaWx0ZXI6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqICAgICAqL1xuICAgIC8qKiBUaGUgY3VzdG9tIGhlYWRlciBjb21wb25lbnQgdG8gYmUgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBjb21wb25lbnQgaGVhZGVyLiBJZiBub25lIHNwZWNpZmllZCB0aGUgZGVmYXVsdCBBRyBHcmlkIGhlYWRlciBjb21wb25lbnQgaXMgdXNlZC5cbiAgICAgICAgICogU2VlIFtIZWFkZXIgQ29tcG9uZW50XShodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9jb21wb25lbnQtaGVhZGVyLykgZm9yIGZyYW1ld29yayBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuICAgICAqL1xuICAgIGhlYWRlckNvbXBvbmVudDogYW55O1xuICAgIC8qKiBAZGVwcmVjYXRlZCBBcyBvZiB2MjcsIHVzZSBgaGVhZGVyQ29tcG9uZW50YCBmb3IgZnJhbWV3b3JrIGNvbXBvbmVudHMgdG9vLlxuICAgICAqL1xuICAgIGhlYWRlckNvbXBvbmVudEZyYW1ld29yazogYW55O1xuICAgIC8qKiBUaGUgcGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIGBoZWFkZXJDb21wb25lbnRgLiAgICAgKi9cbiAgICBoZWFkZXJDb21wb25lbnRQYXJhbXM6IGFueTtcbiAgICAvKiogU2V0IHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgemVybywgb25lIG9yIG1hbnkgb2YgdGhlIGZvbGxvd2luZyBvcHRpb25zOiBgJ2ZpbHRlck1lbnVUYWInIHwgJ2dlbmVyYWxNZW51VGFiJyB8ICdjb2x1bW5zTWVudVRhYidgLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoaWNoIG1lbnUgdGFicyBhcmUgcHJlc2VudCBhbmQgaW4gd2hpY2ggb3JkZXIgdGhlIHRhYnMgYXJlIHNob3duLiAgICAgKi9cbiAgICBtZW51VGFiczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFBhcmFtcyB1c2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3VyIGFuZCBhcHBlYXJhbmNlIG9mIHRoZSBDb2x1bW5zIE1lbnUgdGFiLiAgICAgKi9cbiAgICBjb2x1bW5zTWVudVBhcmFtczogQ29sdW1uc01lbnVQYXJhbXMgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgbm8gbWVudSBzaG91bGQgYmUgc2hvd24gZm9yIHRoaXMgY29sdW1uIGhlYWRlci4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBzdXBwcmVzc01lbnU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIElmIGB0cnVlYCBvciB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAsIGEgJ3NlbGVjdCBhbGwnIGNoZWNrYm94IHdpbGwgYmUgcHV0IGludG8gdGhlIGhlYWRlci4gICAgICovXG4gICAgaGVhZGVyQ2hlY2tib3hTZWxlY3Rpb246IGJvb2xlYW4gfCBIZWFkZXJDaGVja2JveFNlbGVjdGlvbkNhbGxiYWNrIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBJZiBgdHJ1ZWAsIHRoZSBoZWFkZXIgY2hlY2tib3ggc2VsZWN0aW9uIHdpbGwgb25seSBzZWxlY3QgZmlsdGVyZWQgaXRlbXMuICAgICAqL1xuICAgIGhlYWRlckNoZWNrYm94U2VsZWN0aW9uRmlsdGVyZWRPbmx5OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBEZWZpbmVzIHRoZSBjaGFydCBkYXRhIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYSBjb2x1bW4uICAgICAqL1xuICAgIGNoYXJ0RGF0YVR5cGU6ICdjYXRlZ29yeScgfCAnc2VyaWVzJyB8ICd0aW1lJyB8ICdleGNsdWRlZCcgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFBpbiBhIGNvbHVtbiB0byBvbmUgc2lkZTogYHJpZ2h0YCBvciBgbGVmdGAuIEEgdmFsdWUgb2YgYHRydWVgIGlzIGNvbnZlcnRlZCB0byBgJ2xlZnQnYC4gICAgICovXG4gICAgcGlubmVkOiBib29sZWFuIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2FtZSBhcyBgcGlubmVkYCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIGluaXRpYWxQaW5uZWQ6IGJvb2xlYW4gfCBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byB0cnVlIHRvIGJsb2NrIHRoZSB1c2VyIHBpbm5pbmcgdGhlIGNvbHVtbiwgdGhlIGNvbHVtbiBjYW4gb25seSBiZSBwaW5uZWQgdmlhIGRlZmluaXRpb25zIG9yIEFQSS4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBsb2NrUGlubmVkOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgY2VsbFJlbmRlcmVyU2VsZWN0b3IgaWYgeW91IHdhbnQgYSBkaWZmZXJlbnQgQ2VsbCBSZW5kZXJlciBmb3IgcGlubmVkIHJvd3MuIENoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cbiAgICAgKi9cbiAgICBwaW5uZWRSb3dDZWxsUmVuZGVyZXI6IHtcbiAgICAgICAgbmV3ICgpOiBJQ2VsbFJlbmRlcmVyQ29tcDtcbiAgICB9IHwgSUNlbGxSZW5kZXJlckZ1bmMgfCBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBjZWxsUmVuZGVyZXJTZWxlY3RvciBpZiB5b3Ugd2FudCBhIGRpZmZlcmVudCBDZWxsIFJlbmRlcmVyIGZvciBwaW5uZWQgcm93cy4gQ2hlY2sgcGFyYW1zLm5vZGUucm93UGlubmVkLlxuICAgICAqL1xuICAgIHBpbm5lZFJvd0NlbGxSZW5kZXJlckZyYW1ld29yazogYW55O1xuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgY2VsbFJlbmRlcmVyU2VsZWN0b3IgaWYgeW91IHdhbnQgYSBkaWZmZXJlbnQgQ2VsbCBSZW5kZXJlciBmb3IgcGlubmVkIHJvd3MuIENoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cbiAgICAgKi9cbiAgICBwaW5uZWRSb3dDZWxsUmVuZGVyZXJQYXJhbXM6IGFueTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHZhbHVlRm9ybWF0dGVyIGZvciBwaW5uZWQgcm93cywgYW5kIGNoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cbiAgICAgKi9cbiAgICBwaW5uZWRSb3dWYWx1ZUZvcm1hdHRlcjogc3RyaW5nIHwgVmFsdWVGb3JtYXR0ZXJGdW5jIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBwaXZvdCBieSB0aGlzIGNvbHVtbi4gICAgICovXG4gICAgcGl2b3Q6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgYHBpdm90YCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIGluaXRpYWxQaXZvdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRoaXMgaW4gY29sdW1ucyB5b3Ugd2FudCB0byBwaXZvdCBieS5cbiAgICAgKiBJZiBvbmx5IHBpdm90aW5nIGJ5IG9uZSBjb2x1bW4sIHNldCB0aGlzIHRvIGFueSBudW1iZXIgKGUuZy4gYDBgKS5cbiAgICAgKiBJZiBwaXZvdGluZyBieSBtdWx0aXBsZSBjb2x1bW5zLCBzZXQgdGhpcyB0byB3aGVyZSB5b3Ugd2FudCB0aGlzIGNvbHVtbiB0byBiZSBpbiB0aGUgb3JkZXIgb2YgcGl2b3RzIChlLmcuIGAwYCBmb3IgZmlyc3QsIGAxYCBmb3Igc2Vjb25kLCBhbmQgc28gb24pLiAgICAgKi9cbiAgICBwaXZvdEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTYW1lIGFzIGBwaXZvdEluZGV4YCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIGluaXRpYWxQaXZvdEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqIENvbXBhcmF0b3IgdG8gdXNlIHdoZW4gb3JkZXJpbmcgdGhlIHBpdm90IGNvbHVtbnMsIHdoZW4gdGhpcyBjb2x1bW4gaXMgdXNlZCB0byBwaXZvdCBvbi5cbiAgICAgKiBUaGUgdmFsdWVzIHdpbGwgYWx3YXlzIGJlIHN0cmluZ3MsIGFzIHRoZSBwaXZvdCBzZXJ2aWNlIHVzZXMgc3RyaW5ncyBhcyBrZXlzIGZvciB0aGUgcGl2b3QgZ3JvdXBzLiAgICAgKi9cbiAgICBwaXZvdENvbXBhcmF0b3I6ICgodmFsdWVBOiBzdHJpbmcsIHZhbHVlQjogc3RyaW5nKSA9PiBudW1iZXIpIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIGJlIGFibGUgdG8gcGl2b3QgYnkgdGhpcyBjb2x1bW4gdmlhIHRoZSBHVUkuIFRoaXMgd2lsbCBub3QgYmxvY2sgdGhlIEFQSSBvciBwcm9wZXJ0aWVzIGJlaW5nIHVzZWQgdG8gYWNoaWV2ZSBwaXZvdC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBlbmFibGVQaXZvdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogQW4gb2JqZWN0IG9mIGNzcyB2YWx1ZXMgLyBvciBmdW5jdGlvbiByZXR1cm5pbmcgYW4gb2JqZWN0IG9mIGNzcyB2YWx1ZXMgZm9yIGEgcGFydGljdWxhciBjZWxsLiAgICAgKi9cbiAgICBjZWxsU3R5bGU6IENlbGxTdHlsZSB8IENlbGxTdHlsZUZ1bmMgfCB1bmRlZmluZWQ7XG4gICAgLyoqIENsYXNzIHRvIHVzZSBmb3IgdGhlIGNlbGwuIENhbiBiZSBzdHJpbmcsIGFycmF5IG9mIHN0cmluZ3MsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLiAgICAgKi9cbiAgICBjZWxsQ2xhc3M6IHN0cmluZyB8IHN0cmluZ1tdIHwgQ2VsbENsYXNzRnVuYyB8IHVuZGVmaW5lZDtcbiAgICAvKiogUnVsZXMgd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8gaW5jbHVkZSBjZXJ0YWluIENTUyBjbGFzc2VzLiAgICAgKi9cbiAgICBjZWxsQ2xhc3NSdWxlczogQ2VsbENsYXNzUnVsZXMgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFByb3ZpZGUgeW91ciBvd24gY2VsbCBSZW5kZXJlciBjb21wb25lbnQgZm9yIHRoaXMgY29sdW1uJ3MgY2VsbHMuXG4gICAgICogU2VlIFtDZWxsIFJlbmRlcmVyXShodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9jb21wb25lbnQtY2VsbC1yZW5kZXJlci8pIGZvciBmcmFtZXdvcmsgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gZGV0YWlscy4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyOiBhbnk7XG4gICAgLyoqIEBkZXByZWNhdGVkIEFzIG9mIHYyNywgdXNlIGBjZWxsUmVuZGVyZXJgIGZvciBmcmFtZXdvcmsgY29tcG9uZW50cyB0b28uXG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyRnJhbWV3b3JrOiBhbnk7XG4gICAgLyoqIFBhcmFtcyB0byBiZSBwYXNzZWQgdG8gdGhlIGBjZWxsUmVuZGVyZXJgIGNvbXBvbmVudC4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyUGFyYW1zOiBhbnk7XG4gICAgLyoqIENhbGxiYWNrIHRvIHNlbGVjdCB3aGljaCBjZWxsIHJlbmRlcmVyIHRvIGJlIHVzZWQgZm9yIGEgZ2l2ZW4gcm93IHdpdGhpbiB0aGUgc2FtZSBjb2x1bW4uICAgICAqL1xuICAgIGNlbGxSZW5kZXJlclNlbGVjdG9yOiBDZWxsUmVuZGVyZXJTZWxlY3RvckZ1bmMgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gaGF2ZSB0aGUgZ3JpZCBjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiBhIHJvdyBiYXNlZCBvbiBjb250ZW50cyBvZiB0aGlzIGNvbHVtbi4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBhdXRvSGVpZ2h0OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIHRvIGhhdmUgdGhlIHRleHQgd3JhcCBpbnNpZGUgdGhlIGNlbGwgLSB0eXBpY2FsbHkgdXNlZCB3aXRoIGBhdXRvSGVpZ2h0YC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICB3cmFwVGV4dDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBmbGFzaCBhIGNlbGwgd2hlbiBpdCdzIHJlZnJlc2hlZC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBlbmFibGVDZWxsQ2hhbmdlRmxhc2g6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gcHJldmVudCB0aGlzIGNvbHVtbiBmcm9tIGZsYXNoaW5nIG9uIGNoYW5nZXMuIE9ubHkgYXBwbGljYWJsZSBpZiBjZWxsIGZsYXNoaW5nIGlzIHR1cm5lZCBvbiBmb3IgdGhlIGdyaWQuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgc3VwcHJlc3NDZWxsRmxhc2g6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIGBib29sZWFuYCBvciBgRnVuY3Rpb25gLiBTZXQgdG8gYHRydWVgIChvciByZXR1cm4gYHRydWVgIGZyb20gZnVuY3Rpb24pIHRvIGFsbG93IHJvdyBkcmFnZ2luZy4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICByb3dEcmFnOiBib29sZWFuIHwgUm93RHJhZ0NhbGxiYWNrIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBBIGNhbGxiYWNrIHRoYXQgc2hvdWxkIHJldHVybiBhIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgYnkgdGhlIGByb3dEcmFnQ29tcGAgd2hpbGUgZHJhZ2dpbmcgYSByb3cuXG4gICAgICogSWYgdGhpcyBjYWxsYmFjayBpcyBub3Qgc2V0LCB0aGUgY3VycmVudCBjZWxsIHZhbHVlIHdpbGwgYmUgdXNlZC4gICAgICovXG4gICAgcm93RHJhZ1RleHQ6ICgocGFyYW1zOiBJUm93RHJhZ0l0ZW0sIGRyYWdJdGVtQ291bnQ6IG51bWJlcikgPT4gc3RyaW5nKSB8IHVuZGVmaW5lZDtcbiAgICAvKiogYGJvb2xlYW5gIG9yIGBGdW5jdGlvbmAuIFNldCB0byBgdHJ1ZWAgKG9yIHJldHVybiBgdHJ1ZWAgZnJvbSBmdW5jdGlvbikgdG8gYWxsb3cgZHJhZ2dpbmcgZm9yIG5hdGl2ZSBkcmFnIGFuZCBkcm9wLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xuICAgIGRuZFNvdXJjZTogYm9vbGVhbiB8IERuZFNvdXJjZUNhbGxiYWNrIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBGdW5jdGlvbiB0byBhbGxvdyBjdXN0b20gZHJhZyBmdW5jdGlvbmFsaXR5IGZvciBuYXRpdmUgZHJhZyBhbmQgZHJvcC4gICAgICovXG4gICAgZG5kU291cmNlT25Sb3dEcmFnOiAoKHBhcmFtczogRG5kU291cmNlT25Sb3dEcmFnUGFyYW1zKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byByb3cgZ3JvdXAgYnkgdGhpcyBjb2x1bW4uIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgcm93R3JvdXA6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgYHJvd0dyb3VwYCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIGluaXRpYWxSb3dHcm91cDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRoaXMgaW4gY29sdW1ucyB5b3Ugd2FudCB0byBncm91cCBieS5cbiAgICAgKiBJZiBvbmx5IGdyb3VwaW5nIGJ5IG9uZSBjb2x1bW4sIHNldCB0aGlzIHRvIGFueSBudW1iZXIgKGUuZy4gYDBgKS5cbiAgICAgKiBJZiBncm91cGluZyBieSBtdWx0aXBsZSBjb2x1bW5zLCBzZXQgdGhpcyB0byB3aGVyZSB5b3Ugd2FudCB0aGlzIGNvbHVtbiB0byBiZSBpbiB0aGUgZ3JvdXAgKGUuZy4gYDBgIGZvciBmaXJzdCwgYDFgIGZvciBzZWNvbmQsIGFuZCBzbyBvbikuICAgICAqL1xuICAgIHJvd0dyb3VwSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgYHJvd0dyb3VwSW5kZXhgLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXG4gICAgaW5pdGlhbFJvd0dyb3VwSW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBiZSBhYmxlIHRvIHJvdyBncm91cCBieSB0aGlzIGNvbHVtbiB2aWEgdGhlIEdVSS5cbiAgICAgKiBUaGlzIHdpbGwgbm90IGJsb2NrIHRoZSBBUEkgb3IgcHJvcGVydGllcyBiZWluZyB1c2VkIHRvIGFjaGlldmUgcm93IGdyb3VwaW5nLlxuICAgICAqIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgZW5hYmxlUm93R3JvdXA6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gYmUgYWJsZSB0byBhZ2dyZWdhdGUgYnkgdGhpcyBjb2x1bW4gdmlhIHRoZSBHVUkuXG4gICAgICogVGhpcyB3aWxsIG5vdCBibG9jayB0aGUgQVBJIG9yIHByb3BlcnRpZXMgYmVpbmcgdXNlZCB0byBhY2hpZXZlIGFnZ3JlZ2F0aW9uLlxuICAgICAqIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgZW5hYmxlVmFsdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIE5hbWUgb2YgZnVuY3Rpb24gdG8gdXNlIGZvciBhZ2dyZWdhdGlvbi4gWW91IGNhbiBhbHNvIHByb3ZpZGUgeW91ciBvd24gYWdnIGZ1bmN0aW9uLiAgICAgKi9cbiAgICBhZ2dGdW5jOiBzdHJpbmcgfCBJQWdnRnVuYyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgYGFnZ0Z1bmNgLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXG4gICAgaW5pdGlhbEFnZ0Z1bmM6IHN0cmluZyB8IElBZ2dGdW5jIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBBZ2dyZWdhdGlvbiBmdW5jdGlvbnMgYWxsb3dlZCBvbiB0aGlzIGNvbHVtbiBlLmcuIGBbJ3N1bScsICdhdmcnXWAuXG4gICAgICogSWYgbWlzc2luZywgYWxsIGluc3RhbGxlZCBmdW5jdGlvbnMgYXJlIGFsbG93ZWQuXG4gICAgICogVGhpcyB3aWxsIG9ubHkgcmVzdHJpY3Qgd2hhdCB0aGUgR1VJIGFsbG93cyBhIHVzZXIgdG8gc2VsZWN0LCBpdCBkb2VzIG5vdCBpbXBhY3Qgd2hlbiB5b3Ugc2V0IGEgZnVuY3Rpb24gdmlhIHRoZSBBUEkuICAgICAqL1xuICAgIGFsbG93ZWRBZ2dGdW5jczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGdyaWQgcGxhY2UgdGhlIHZhbHVlcyBmb3IgdGhlIGdyb3VwIGludG8gdGhlIGNlbGwsIG9yIHB1dCB0aGUgbmFtZSBvZiBhIGdyb3VwZWQgY29sdW1uIHRvIGp1c3Qgc2hvdyB0aGF0IGdyb3VwLiAgICAgKi9cbiAgICBzaG93Um93R3JvdXA6IHN0cmluZyB8IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gYWxsb3cgc29ydGluZyBvbiB0aGlzIGNvbHVtbi4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBzb3J0YWJsZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogSWYgc29ydGluZyBieSBkZWZhdWx0LCBzZXQgaXQgaGVyZS4gU2V0IHRvIGBhc2NgIG9yIGBkZXNjYC4gICAgICovXG4gICAgc29ydDogJ2FzYycgfCAnZGVzYycgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTYW1lIGFzIGBzb3J0YCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIGluaXRpYWxTb3J0OiAnYXNjJyB8ICdkZXNjJyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgLyoqIElmIHNvcnRpbmcgbW9yZSB0aGFuIG9uZSBjb2x1bW4gYnkgZGVmYXVsdCwgc3BlY2lmaWVzIG9yZGVyIGluIHdoaWNoIHRoZSBzb3J0aW5nIHNob3VsZCBiZSBhcHBsaWVkLiAgICAgKi9cbiAgICBzb3J0SW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNhbWUgYXMgYHNvcnRJbmRleGAsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cbiAgICBpbml0aWFsU29ydEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqIEFycmF5IGRlZmluaW5nIHRoZSBvcmRlciBpbiB3aGljaCBzb3J0aW5nIG9jY3VycyAoaWYgc29ydGluZyBpcyBlbmFibGVkKS4gQW4gYXJyYXkgd2l0aCBhbnkgb2YgdGhlIGZvbGxvd2luZyBpbiBhbnkgb3JkZXIgYFsnYXNjJywnZGVzYycsbnVsbF1gICAgICAqL1xuICAgIHNvcnRpbmdPcmRlcjogKCdhc2MnIHwgJ2Rlc2MnIHwgbnVsbClbXSB8IHVuZGVmaW5lZDtcbiAgICAvKiogQ29tcGFyYXRvciBmdW5jdGlvbiBmb3IgY3VzdG9tIHNvcnRpbmcuICAgICAqL1xuICAgIGNvbXBhcmF0b3I6ICgodmFsdWVBOiBhbnksIHZhbHVlQjogYW55LCBub2RlQTogUm93Tm9kZSwgbm9kZUI6IFJvd05vZGUsIGlzSW52ZXJ0ZWQ6IGJvb2xlYW4pID0+IG51bWJlcikgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdGhlIHVuc29ydGVkIGljb24gdG8gYmUgc2hvd24gd2hlbiBubyBzb3J0IGlzIGFwcGxpZWQgdG8gdGhpcyBjb2x1bW4uIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgdW5Tb3J0SWNvbjogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogQGRlcHJlY2F0ZWQgc2luY2UgdjI0IC0gdXNlIHNvcnRJbmRleCBpbnN0ZWFkXG4gICAgICovXG4gICAgc29ydGVkQXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKiogQnkgZGVmYXVsdCwgZWFjaCBjZWxsIHdpbGwgdGFrZSB1cCB0aGUgd2lkdGggb2Ygb25lIGNvbHVtbi4gWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvdXIgdG8gYWxsb3cgY2VsbHMgdG8gc3BhbiBtdWx0aXBsZSBjb2x1bW5zLiAgICAgKi9cbiAgICBjb2xTcGFuOiAoKHBhcmFtczogQ29sU3BhblBhcmFtcykgPT4gbnVtYmVyKSB8IHVuZGVmaW5lZDtcbiAgICAvKiogQnkgZGVmYXVsdCwgZWFjaCBjZWxsIHdpbGwgdGFrZSB1cCB0aGUgaGVpZ2h0IG9mIG9uZSByb3cuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYmVoYXZpb3VyIHRvIGFsbG93IGNlbGxzIHRvIHNwYW4gbXVsdGlwbGUgcm93cy4gICAgICovXG4gICAgcm93U3BhbjogKChwYXJhbXM6IFJvd1NwYW5QYXJhbXMpID0+IG51bWJlcikgfCB1bmRlZmluZWQ7XG4gICAgLyoqIEluaXRpYWwgd2lkdGggaW4gcGl4ZWxzIGZvciB0aGUgY2VsbC4gICAgICovXG4gICAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2FtZSBhcyBgd2lkdGhgLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXG4gICAgaW5pdGlhbFdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqIE1pbmltdW0gd2lkdGggaW4gcGl4ZWxzIGZvciB0aGUgY2VsbC4gICAgICovXG4gICAgbWluV2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKiogTWF4aW11bSB3aWR0aCBpbiBwaXhlbHMgZm9yIHRoZSBjZWxsLiAgICAgKi9cbiAgICBtYXhXaWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBVc2VkIGluc3RlYWQgb2YgYHdpZHRoYCB3aGVuIHRoZSBnb2FsIGlzIHRvIGZpbGwgdGhlIHJlbWFpbmluZyBlbXB0eSBzcGFjZSBvZiB0aGUgZ3JpZC4gICAgICovXG4gICAgZmxleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTYW1lIGFzIGBmbGV4YCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xuICAgIGluaXRpYWxGbGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gYWxsb3cgdGhpcyBjb2x1bW4gc2hvdWxkIGJlIHJlc2l6ZWQuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXG4gICAgcmVzaXphYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRoaXMgY29sdW1uJ3Mgd2lkdGggdG8gYmUgZml4ZWQgZHVyaW5nICdzaXplIHRvIGZpdCcgb3BlcmF0aW9ucy4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBzdXBwcmVzc1NpemVUb0ZpdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB5b3UgZG8gbm90IHdhbnQgdGhpcyBjb2x1bW4gdG8gYmUgYXV0by1yZXNpemFibGUgYnkgZG91YmxlIGNsaWNraW5nIGl0J3MgZWRnZS4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cbiAgICBzdXBwcmVzc0F1dG9TaXplOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc0NlbGxGbGFzaDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NDb2x1bW5zVG9vbFBhbmVsOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc0ZpbHRlcnNUb29sUGFuZWw6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX29wZW5CeURlZmF1bHQ6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX21hcnJ5Q2hpbGRyZW46IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2hpZGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2luaXRpYWxIaWRlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yb3dHcm91cDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaW5pdGlhbFJvd0dyb3VwOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9waXZvdDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaW5pdGlhbFBpdm90OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jaGVja2JveFNlbGVjdGlvbjogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaGVhZGVyQ2hlY2tib3hTZWxlY3Rpb246IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2hlYWRlckNoZWNrYm94U2VsZWN0aW9uRmlsdGVyZWRPbmx5OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc01lbnU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzTW92YWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbG9ja1Bvc2l0aW9uOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9sb2NrVmlzaWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbG9ja1Bpbm5lZDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfdW5Tb3J0SWNvbjogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NTaXplVG9GaXQ6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzQXV0b1NpemU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2VuYWJsZVJvd0dyb3VwOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9lbmFibGVQaXZvdDogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZW5hYmxlVmFsdWU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2VkaXRhYmxlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc1Bhc3RlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc05hdmlnYWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZW5hYmxlQ2VsbENoYW5nZUZsYXNoOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yb3dEcmFnOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9kbmRTb3VyY2U6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2F1dG9IZWlnaHQ6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3dyYXBUZXh0OiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zb3J0YWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcmVzaXphYmxlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zaW5nbGVDbGlja0VkaXQ6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2Zsb2F0aW5nRmlsdGVyOiBib29sZWFuIHwgbnVsbCB8ICcnO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jZWxsRWRpdG9yUG9wdXA6IGJvb2xlYW4gfCBudWxsIHwgJyc7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzRmlsbEhhbmRsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcbn1cbiJdfQ==